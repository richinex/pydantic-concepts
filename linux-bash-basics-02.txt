Flow Control and Text Processing
=====================================

Test Operators in Bash

Bash allows us to selectively execute commands when certain conditions are met. By using test operators, we can craft a wide variety of conditions, such as determining whether one value equals another, whether a file is of a specific type, or whether one value is greater than another. These tests are fundamental to Bash programming, as they help decide whether to continue running a block of code.
Types of Test Operators

Bash provides multiple kinds of test operators, each serving different purposes. The primary categories include File Test Operators, String Comparison Operators, and Integer Comparison Operators.
1. File Test Operators

File test operators allow us to perform checks against files on the filesystem. For example, we can verify whether a file is executable or whether a certain directory exists.
Table 2-1: File Test Operators

vbnet

+--------+-------------------------------------------+
| Operator | Description                              |
+--------+-------------------------------------------+
| -d     | Checks whether the file is a directory    |
| -r     | Checks whether the file is readable       |
| -x     | Checks whether the file is executable     |
| -w     | Checks whether the file is writable       |
| -f     | Checks whether the file is a regular file  |
| -s     | Checks whether the file size is > 0        |
+--------+-------------------------------------------+

For a comprehensive list of file test operators, visit SS64 Bash Test or run the man test command in your terminal.
2. String Comparison Operators

String comparison operators enable us to perform tests related to strings, such as checking whether one string is equal to another.
Table 2-2: String Comparison Operators

vbnet

+--------+-----------------------------------------------------------+
| Operator | Description                                              |
+--------+-----------------------------------------------------------+
| =      | Checks whether a string is equal to another string         |
| ==     | Synonym of = when used within [[ ]] constructs            |
| !=     | Checks whether a string is not equal to another string     |
| <      | Checks whether a string comes before another string (alphabetical order) |
| >      | Checks whether a string comes after another string (alphabetical order)  |
| -z     | Checks whether a string is null                            |
| -n     | Checks whether a string is not null                        |
+--------+-----------------------------------------------------------+

3. Integer Comparison Operators

Integer comparison operators allow us to perform checks on integers, such as determining whether one integer is less than or greater than another.
Table 2-3: Integer Comparison Operators

vbnet

+--------+-----------------------------------------------------------+
| Operator | Description                                              |
+--------+-----------------------------------------------------------+
| -eq    | Checks whether a number is equal to another number         |
| -ne    | Checks whether a number is not equal to another number     |
| -ge    | Checks whether a number is greater than or equal to another number |
| -gt    | Checks whether a number is greater than another number     |
| -lt    | Checks whether a number is less than another number        |
| -le    | Checks whether a number is less than or equal to another number |
+--------+-----------------------------------------------------------+

Using Test Operators in Flow Control

Test operators are often used within flow-control mechanisms to determine which block of code to execute next. The primary structure used for this purpose is the if statement.
1. if Conditions

In Bash, the if statement allows you to execute code only when a certain condition is met.
Syntax of an if Statement

bash

if [[ condition ]]; then
  # Do something if the condition is met.
else
  # Do something if the condition is not met.
fi

Listing 2-1: The Structure of an if Statement

bash

#!/bin/bash

if [[ condition ]]; then
  # Do something if the condition is met.
else
  # Do something if the condition is not met.
fi

    if Keyword: Begins the if statement.
    [[ condition ]]: Encloses the test condition within double square brackets.
    ; Character: Separates the if keyword from the then keyword.
    then Keyword: Introduces the block of code that runs if the condition is true.
    else Keyword: Introduces the fallback code block that runs if the condition is false. This is optional.
    fi Keyword: Closes the if statement (fi is if spelled backward).

    Note: In some operating systems, such as those used in containers, the default shell might not be Bash. To ensure portability across different Unix derivatives, you may use single square brackets [ ] instead of double brackets [[ ]] to enclose your condition.

2. Practical Examples of if Conditions
Listing 2-2: Testing for the Existence of a File

bash

#!/bin/bash
FILENAME="flow_control_with_if.txt"

if [[ -f "${FILENAME}" ]]; then
  echo "${FILENAME} already exists."
  exit 1
else
  touch "${FILENAME}"
fi

    Explanation:
        Variable Assignment: FILENAME holds the name of the file to check.
        if Statement: Uses the -f file test operator to check if the file exists.
        then Block: If the file exists, it prints a message and exits the script with status code 1.
        else Block: If the file does not exist, it creates the file using the touch command.

    Note: You can download the scripts from GitHub Repository.

Listing 2-3: Using a Negative Check to Test File Existence

bash

#!/bin/bash
FILENAME="flow_control_with_if.txt"

if [[ ! -f "${FILENAME}" ]]; then
  touch "${FILENAME}"
fi

    Explanation:
        ! Operator: Negates the condition, checking if the file does not exist.
        Simplified Logic: If the file does not exist, it creates the file. This approach reduces the number of lines and eliminates the need for an else block.

Listing 2-4: Comparing Two String Variables

bash

#!/bin/bash
VARIABLE_ONE="nostarch"
VARIABLE_TWO="nostarch"

if [[ "${VARIABLE_ONE}" == "${VARIABLE_TWO}" ]]; then
  echo "They are equal!"
else
  echo "They are not equal!"
fi

    Explanation:
        String Comparison: Uses the == operator to check if VARIABLE_ONE is equal to VARIABLE_TWO.
        Output: Since both variables contain "nostarch", it prints "They are equal!"

Listing 2-5: Comparing Integers

bash

#!/bin/bash
VARIABLE_ONE=10
VARIABLE_TWO=20

if [[ "${VARIABLE_ONE}" -gt "${VARIABLE_TWO}" ]]; then
  echo "${VARIABLE_ONE} is greater than ${VARIABLE_TWO}."
else
  echo "${VARIABLE_ONE} is less than ${VARIABLE_TWO}."
fi

    Explanation:
        Integer Comparison: Uses the -gt (greater than) operator to compare VARIABLE_ONE and VARIABLE_TWO.
        Output: Since 10 is less than 20, it prints "10 is less than 20."

3. Linking Conditions

Bash allows you to combine multiple conditions using logical operators such as AND (&&) and OR (||).
3.1 Using AND (&&) to Chain Conditions

bash

#!/bin/bash

echo "Hello World!" > file.txt

if [[ -f "file.txt" ]] && [[ -s "file.txt" ]]; then
  echo "The file exists and its size is greater than zero."
fi

    Explanation:
        -f "file.txt": Checks if file.txt exists.
        -s "file.txt": Checks if file.txt has a size greater than zero.
        Logical AND: Both conditions must be true for the echo command to execute.

3.2 Using OR (||) to Chain Conditions

bash

#!/bin/bash
DIR_NAME="dir_test"

mkdir "${DIR_NAME}"

if [[ -f "${DIR_NAME}" ]] || [[ -d "${DIR_NAME}" ]]; then
  echo "${DIR_NAME} is either a file or a directory."
fi

    Explanation:
        -f "${DIR_NAME}": Checks if DIR_NAME is a file.
        -d "${DIR_NAME}": Checks if DIR_NAME is a directory.
        Logical OR: If either condition is true, the echo command executes. Since dir_test is a directory, it prints the message.

4. Testing Command Success

You can test the exit status of commands to determine whether they were successful. This technique is commonly used in Bash scripting since commands can fail for various reasons, such as insufficient permissions or unavailable resources.
Listing 2-8: Executing Commands Based on Exit Code Values

bash

if command; then
  # command was successful.
fi

if ! command; then
  # command was unsuccessful.
fi

    Explanation:
        First if Statement: Executes the block if command succeeds (exit code 0).
        Second if Statement: Executes the block if command fails (non-zero exit code) by using the ! operator to negate the condition.

Example:

bash

$ if touch test123; then
    echo "OK: file created"
  fi

OK: file created

    Explanation:
        touch test123: Attempts to create a file named test123.
        Output: If the file creation is successful, it prints "OK: file created."

5. Checking Subsequent Conditions with elif

If the initial if condition fails, you can check additional conditions using the elif (else if) keyword. This allows for multiple conditional branches within a single if statement.
Listing 2-9: Using if and elif Statements

bash

#!/bin/bash
USER_INPUT="${1}"

# ❶ Check if USER_INPUT is null
if [[ -z "${USER_INPUT}" ]]; then
  echo "You must provide an argument!"
  exit 1
fi

# ❷ Check if USER_INPUT is a file
if [[ -f "${USER_INPUT}" ]]; then
  echo "${USER_INPUT} is a file."
# ❸ Check if USER_INPUT is a directory
elif [[ -d "${USER_INPUT}" ]]; then
  echo "${USER_INPUT} is a directory."
# ❹ If neither, respond accordingly
else
  echo "${USER_INPUT} is not a file or a directory."
fi

    Explanation:
        ❶ Check for Argument: Uses -z to check if USER_INPUT is null. If no argument is provided, it prints a message and exits with status code 1.
        ❷ Check for File: Uses -f to check if USER_INPUT is a file. If true, it prints that it's a file.
        ❸ Check for Directory: Uses -d to check if USER_INPUT is a directory. If true, it prints that it's a directory.
        ❹ Else Clause: If neither condition is met, it prints that USER_INPUT is neither a file nor a directory.

Additional Notes

    Portability Consideration: While double square brackets [[ ]] are preferred in Bash for their extended functionality, using single square brackets [ ] ensures better portability across different Unix-like systems.
    Exiting with Status Codes: Using exit with appropriate status codes (e.g., exit 1 for failure) is a good practice to indicate the success or failure of script execution.

Conclusion

Test operators are essential tools in Bash scripting, enabling you to perform a wide range of conditional checks on files, strings, and integers. By mastering these operators and understanding how to incorporate them into if statements and other flow-control mechanisms, you can write more robust and flexible Bash scripts.


Bash Functions, Loops, and Case Statements

Functions, loops, and case statements are fundamental constructs in Bash scripting that enhance code reusability, control flow, and readability. This section explores how to define and use functions, implement various types of loops, and utilize case statements to handle multiple conditions efficiently.
Functions

Functions in Bash allow you to encapsulate reusable blocks of code. By defining functions, you can execute multiple commands simultaneously by simply invoking the function's name, thereby avoiding code repetition.
Defining a Function

To define a new function, provide a name followed by parentheses (), and enclose the desired commands within curly brackets {}.
Listing 2-10: Defining a Function

bash

#!/bin/bash

say_name(){
  echo "Black Hat Bash"
}

Explanation:

    Function Name: say_name
    Function Body: Executes a single echo command that prints "Black Hat Bash".

Calling a Function

To execute the commands within a function, simply call its name:

bash

say_name

Note: If the function is not called, the commands within it will not run.
Returning Values

Functions can return values using the return keyword. If a function lacks a return statement, it will return the exit code of the last executed command.
Listing 2-11: Function Returning Values Based on User Privileges

bash

#!/bin/bash

# This function checks if the current user ID equals zero.
check_if_root(){
  if [[ "${EUID}" -eq "0" ]]; then
    return 0
  else
    return 1
  fi
}

if check_if_root; then
  echo "User is root!"
else
  echo "User is not root!"
fi

Explanation:

    Function Definition (check_if_root):
        Checks if the effective user ID (EUID) is 0, which indicates the root user.
        Returns 0 (success) if the user is root, otherwise returns 1 (failure).
    Function Invocation:
        Calls check_if_root.
        If the function returns 0, it echoes "User is root!".
        If the function returns 1, it echoes "User is not root!".

Usage Scenario: Bash scripts performing privileged actions (e.g., installing software, creating users) often check if the user is root to prevent errors due to insufficient permissions.
Accepting Arguments

Functions can accept arguments, allowing you to pass data into them for processing.
Listing 2-12: Function with Arguments

bash

#!/bin/bash

print_args(){
  echo "first: ${1}, second: ${2}, third: ${3}"
}

print_args No Starch Press

Explanation:

    Function Definition (print_args):
        Prints the first three arguments passed to the function.
    Function Call:
        Passes "No", "Starch", and "Press" as arguments.

Output:

yaml

first: No, second: Starch, third: Press

Usage: This technique allows functions to handle dynamic input, making scripts more flexible and reusable.
Loops and Loop Controls

Loops enable the repetition of code blocks, which is particularly useful for tasks like monitoring system states, iterating through lists, or automating repetitive tasks in penetration testing.
Types of Loops in Bash

    while Loop
    until Loop
    for Loop

Additionally, loop controls such as break and continue allow for more granular control within loops.
1. while Loop

The while loop executes a block of code as long as a specified condition remains true.
Listing 2-13: Syntax of a while Loop

bash

while some_condition; do
  # Run commands while the condition is true.
done

Explanation:

    while Keyword: Initiates the loop.
    some_condition: The loop continues as long as this condition is true.
    do and done: Enclose the commands to be executed during each iteration.

Infinite while Loop Example

bash

#!/bin/bash

while true; do
  echo "Looping..."
  sleep 2
done

Listing 2-14: Repeatedly Running a Command at Two-Second Intervals

Explanation:

    Condition: true always returns a successful exit code, creating an infinite loop.
    Commands:
        echo "Looping...": Prints "Looping..." to the screen.
        sleep 2: Pauses execution for 2 seconds.

Execution:

bash

$ chmod u+x basic_while.sh
$ ./basic_while.sh

Looping...
Looping...
--snip--

Monitoring for a Specific File with a while Loop

bash

#!/bin/bash
SIGNAL_TO_STOP_FILE="stoploop"

while [[ ! -f "${SIGNAL_TO_STOP_FILE}" ]]; do
  echo "The file ${SIGNAL_TO_STOP_FILE} does not yet exist..."
  echo "Checking again in 2 seconds..."
  sleep 2
done

echo "File was found! Exiting..."

Listing 2-15: File Monitoring

Explanation:

    Variable Definition (SIGNAL_TO_STOP_FILE): Specifies the filename to monitor.
    while Loop Condition: Checks if the file does not exist using ! -f.
    Loop Commands:
        Echoes status messages.
        Sleeps for 2 seconds before rechecking.
    Post-Loop Command: Once the file exists, it echoes a confirmation message.

Execution:

bash

$ chmod u+x while_loop.sh
$ ./while_loop.sh

The file stoploop does not yet exist...
Checking again in 2 seconds...
--snip--

Stopping the Loop: Open another terminal and create the file:

bash

$ touch stoploop

Output After File Creation:

arduino

File was found! Exiting...

Use Cases:

    Monitoring filesystem events (e.g., file creation or deletion).
    Waiting for processes to start before executing dependent commands.

2. until Loop

The until loop runs a block of code until a specified condition becomes true. It is essentially the inverse of the while loop.
Listing 2-16: Syntax of an until Loop

bash

until some_condition; do
  # Run some commands until the condition is no longer false.
done

Explanation:

    until Keyword: Initiates the loop.
    some_condition: The loop continues until this condition becomes true.
    do and done: Enclose the commands to be executed during each iteration.

Example: Checking a File’s Size

bash

#!/bin/bash
FILE="output.txt"

touch "${FILE}"
until [[ -s "${FILE}" ]]; do
  echo "${FILE} is empty..."
  echo "Checking again in 2 seconds..."
  sleep 2
done

echo "${FILE} appears to have some content in it!"

Listing 2-17: Checking a File’s Size

Explanation:

    File Creation (touch "${FILE}"): Creates an empty file named output.txt.
    until Loop Condition: Continues looping until the file is not empty (-s checks if the file size is greater than zero).
    Loop Commands:
        Echoes status messages.
        Sleeps for 2 seconds before rechecking.
    Post-Loop Command: Once the file has content, it echoes a confirmation message.

Execution:

bash

$ chmod u+x until_loop.sh
$ ./until_loop.sh

output.txt is empty...
Checking again in 2 seconds...
--snip--

Adding Content to Stop the Loop: Open another terminal and append content to the file:

bash

$ echo "until_loop_will_now_stop!" > output.txt

Output After Adding Content:

css

output.txt appears to have some content in it!

Use Cases:

    Waiting for a file to be populated before processing.
    Monitoring changes in system resources or application states.

3. for Loop

The for loop iterates over a sequence of items, executing a block of commands for each item in the sequence.
Listing 2-18: Syntax of a for Loop

bash

for variable_name in LIST; do
  # Run some commands for each item in the sequence.
done

Explanation:

    for Keyword: Initiates the loop.
    variable_name: Temporarily holds the current item from the list during each iteration.
    LIST: The sequence of items to iterate over.
    do and done: Enclose the commands to be executed for each item.

Example: Counting to 10

bash

#!/bin/bash

for index in $(seq 1 10); do
  echo "${index}"
done

Listing 2-19: Counting to 10 in a for Loop

Explanation:

    Sequence Generation ($(seq 1 10)): Generates numbers from 1 to 10.
    Loop Body: Echoes each number.

Execution:

bash

$ chmod u+x count_to_10.sh
$ ./count_to_10.sh

1
2
3
4
5
6
7
8
9
10

Practical Example: Iterating Through Command Line Arguments

bash

#!/bin/bash

for ip_address in "$@"; do
  echo "Taking some action on IP address ${ip_address}"
done

Listing 2-20: Iterating Through Command Line Arguments

Explanation:

    "$@": Represents all arguments passed to the script.
    Loop Body: Echoes a message for each IP address.

Execution:

bash

$ chmod u+x for_loop_arguments.sh
$ ./for_loop_arguments.sh 10.0.0.1 10.0.0.2 192.168.1.1 192.168.1.2

Taking some action on IP address 10.0.0.1
Taking some action on IP address 10.0.0.2
Taking some action on IP address 192.168.1.1
Taking some action on IP address 192.168.1.2

Example: Iterating Through Files in the Current Directory

bash

#!/bin/bash

for file in $(ls .); do
  echo "File: ${file}"
done

Listing 2-21: Iterating Through Files in the Current Directory

Explanation:

    Command Substitution ($(ls .)): Lists all files in the current directory.
    Loop Body: Echoes the name of each file.

Execution:

bash

$ chmod u+x list_files.sh
$ ./list_files.sh

File: file1.txt
File: script.sh
File: image.png
--snip--

Use Cases:

    Automating tasks across multiple files or systems.
    Performing bulk operations like uploading or renaming files.

Loop Controls: break and continue

Loop controls allow you to alter the flow of loop execution. The break statement exits the loop entirely, while the continue statement skips the current iteration and proceeds to the next one.
break Statement

The break statement terminates the loop, allowing the script to continue with the subsequent code outside the loop.

bash

#!/bin/bash

while true; do
  echo "in the loop"
  break
done

echo "This code block will be reached."

Listing 2-22: Breaking from a Loop

Explanation:

    Infinite Loop (while true): Continuously echoes "in the loop".
    break: Exits the loop immediately.
    Post-Loop Echo: Prints "This code block will be reached."

Execution:

bash

$ chmod u+x break_loop.sh
$ ./break_loop.sh

in the loop
This code block will be reached.

continue Statement

The continue statement skips the current iteration of the loop and moves to the next one. This is useful for excluding specific items from processing.
Example: Skipping an Element in a for Loop

    Create Example Files:

    bash

$ touch example_file1 example_file2 example_file3

Script to Skip the First File:

bash

#!/bin/bash

for file in example_file*; do
  if [[ "${file}" == "example_file1" ]]; then
    echo "Skipping the first file"
    continue
  fi

  echo "${RANDOM}" > "${file}"
done

Listing 2-23: Skipping an Element in a for Loop

Explanation:

    Loop Iteration (example_file*): Iterates over files matching the pattern.
    Condition Check: If the file is example_file1, it echoes a message and uses continue to skip to the next iteration.
    Action on Other Files: Writes a random number to the file using ${RANDOM}.

Execution:

bash

    $ chmod u+x for_loop_continue.sh
    $ ./for_loop_continue.sh

    Skipping the first file

    Result:
        example_file1 remains empty.
        example_file2 and example_file3 contain random numbers.

Use Cases:

    Skipping specific items based on conditions.
    Avoiding processing of invalid or unwanted data within loops.

Case Statements

Case statements provide a way to execute different blocks of code based on the value of a variable. They offer a cleaner and more readable alternative to multiple if-elif-else conditions, especially when dealing with numerous cases.
Syntax of a Case Statement
Listing 2-24: Syntax of a Case Statement

bash

case EXPRESSION in
  PATTERN1)
    # Do something if the first condition is met.
  ;;
  PATTERN2)
    # Do something if the second condition is met.
  ;;
esac

Explanation:

    case Keyword: Initiates the case statement.
    EXPRESSION: The value to be matched against patterns.
    PATTERN: The specific patterns to match the expression.
    ;;: Denotes the end of each pattern's commands.
    esac: Ends the case statement (esac is case spelled backward).

Example: Checking an IP Address's Network

bash

#!/bin/bash
IP_ADDRESS="${1}"

case ${IP_ADDRESS} in
  192.168.*)
    echo "Network is 192.168.x.x"
  ;;
  10.0.*)
    echo "Network is 10.0.x.x"
  ;;
  *)
    echo "Could not identify the network"
  ;;
esac

Listing 2-25: Checking an IP Address and Determining Its Network

Explanation:

    Variable Definition (IP_ADDRESS): Captures the first command line argument.
    Case Statement:
        Pattern 192.168.*: Matches IP addresses starting with 192.168..
        Pattern 10.0.*: Matches IP addresses starting with 10.0..
        Wildcard *: Catches all other cases.
    Actions:
        Echoes the corresponding network based on the matched pattern.

Execution:

bash

$ chmod u+x case_ip_address_check.sh
$ ./case_ip_address_check.sh 192.168.12.55
Network is 192.168.x.x

$ ./case_ip_address_check.sh 212.199.2.2
Could not identify the network

Use Cases:

    Handling user input with multiple possible values.
    Executing different functions based on configuration options.
    Simplifying complex conditional logic for better readability.

Additional Notes

    Portability Considerations: While double square brackets [[ ]] offer extended functionality in Bash, using single square brackets [ ] ensures better portability across different Unix-like systems.
    Exit Status Codes: Utilizing appropriate exit codes (e.g., exit 1 for failure) is a good practice to indicate the success or failure of script execution.
    Script Permissions: Ensure scripts are executable by setting the correct permissions using chmod u+x script_name.sh.

Conclusion

Mastering functions, loops, and case statements in Bash significantly enhances your scripting capabilities. These constructs enable you to write more efficient, readable, and maintainable scripts by promoting code reuse, automating repetitive tasks, and handling complex conditional logic seamlessly.
References

    SS64 Bash Test Operators
    GNU Bash Manual

Download Scripts

You can download the scripts referenced in this section from the GitHub Repository.
Example Executions
Function Execution

bash

$ ./test_if_file_exists.sh
OK: file created

Result: The script creates flow_control_with_if.txt and echoes a confirmation message.
Loop Execution
Infinite while Loop

bash

$ ./basic_while.sh

Looping...
Looping...
--snip--

Note: Use CTRL-C to stop the infinite loop.
File Monitoring with while Loop

bash

$ ./while_loop.sh

The file stoploop does not yet exist...
Checking again in 2 seconds...
--snip--

After creating the stoploop file:

arduino

File was found! Exiting...

for Loop with Command Line Arguments

bash

$ ./for_loop_arguments.sh 10.0.0.1 10.0.0.2 192.168.1.1 192.168.1.2

Taking some action on IP address 10.0.0.1
Taking some action on IP address 10.0.0.2
Taking some action on IP address 192.168.1.1
Taking some action on IP address 192.168.1.2

Loop Control with continue

bash

$ ./for_loop_continue.sh

Skipping the first file

Result:

    example_file1 remains empty.
    example_file2 and example_file3 contain random numbers.

Case Statement Execution

bash

$ ./case_ip_address_check.sh 192.168.12.55
Network is 192.168.x.x

$ ./case_ip_address_check.sh 212.199.2.2
Could not identify the network

Summary

Understanding and effectively utilizing functions, loops, and case statements in Bash is crucial for writing robust and efficient scripts. These constructs allow you to automate complex tasks, manage control flow, and handle multiple conditions with ease, making your Bash scripting endeavors more productive and less error-prone.

Bash Text Processing and Parsing

Text processing and parsing are integral parts of Bash scripting. Whether you're filtering logs, extracting specific data, or modifying text streams, Bash provides powerful tools to handle these tasks efficiently. This section delves into three primary text processing utilities in Bash: grep, awk, and sed. Additionally, we'll explore diverse and practical examples to demonstrate their capabilities.

To follow along with the examples in this section, download the sample logfile from GitHub Repository. This file is space-separated, with each segment representing specific data types such as the client’s source IP address, timestamp, HTTP method, HTTP path, HTTP User Agent field, HTTP status code, and more.
Table of Contents

    Filtering with grep
    Filtering with awk
    Editing Streams with sed
    Additional Examples and Practical Use Cases
    Conclusion
    References

Filtering with grep

The grep command is one of the most widely used Linux commands for searching text using patterns. It allows you to filter out information of interest from streams or files based on specific patterns.
Basic Usage

To filter lines containing a specific string:

bash

grep "35.237.4.214" log.txt

Listing 2-26: Filtering for a Specific String from a File

bash

$ grep "35.237.4.214" log.txt

Explanation:

    Searches for the IP address 35.237.4.214 within log.txt.
    Outputs all lines containing the specified IP address.

Filtering with Multiple Patterns

You can search for multiple patterns simultaneously using the backslash pipe (\|) as an OR condition or the -e flag.
Using Backslash Pipe (\|)

bash

grep "35.237.4.214\|13.66.139.0" log.txt

Using Multiple -e Flags

bash

grep -e "35.237.4.214" -e "13.66.139.0" log.txt

Explanation:

    Both commands search for lines containing either 35.237.4.214 or 13.66.139.0.
    The first uses a single grep command with an OR regex.
    The second uses multiple -e flags to specify each pattern.

Combining grep with Other Commands Using Pipes

You can use the pipe (|) to pass the output of one command as the input to another. For example, to filter processes related to TTY:

bash

ps | grep TTY

Making Searches Case-Insensitive

By default, grep is case-sensitive. Use the -i flag to ignore case:

bash

ps | grep -i tty

Excluding Lines with -v

To exclude lines containing a certain pattern, use the -v flag:

bash

grep -v "35.237.4.214" log.txt

Explanation:

    Outputs all lines not containing 35.237.4.214.

Printing Only Matched Patterns with -o

To print only the matched part of the line, use the -o flag:

bash

grep -o "35.237.4.214" log.txt

Explanation:

    Outputs only the IP address 35.237.4.214 wherever it appears, without the rest of the line.

Advanced grep Features

grep supports regular expressions, anchoring, grouping, and more. Refer to the grep Manual for comprehensive details.
Filtering with awk

awk is a versatile text processing tool that excels at pattern scanning and processing. It allows you to extract and manipulate data based on specific fields.
Basic Usage

To print the first field (e.g., IP addresses) from each line:

bash

awk '{print $1}' log.txt

Explanation:

    {print $1} instructs awk to print the first field of each line.
    Fields are, by default, separated by spaces or tabs.

Printing Multiple Fields

To print the first three fields (e.g., IP address, timestamp, HTTP method):

bash

awk '{print $1, $2, $3}' log.txt

Explanation:

    {print $1, $2, $3} prints the first, second, and third fields separated by spaces.

Printing Specific Fields Simultaneously

To print the first and last fields:

bash

awk '{print $1, $NF}' log.txt

Explanation:

    $NF represents the last field in the current record (line).

Changing the Default Delimiter

If your file uses a different delimiter, such as commas, specify it with the -F flag:

bash

awk -F',' '{print $1}' example_csv.txt

Explanation:

    -F',' sets the field separator to a comma.
    {print $1} prints the first field of each line.

Printing a Range of Lines

To emulate the head command by printing the first 10 lines:

bash

awk 'NR < 10' log.txt

Explanation:

    NR stands for "Number of Records" and increments with each line.
    NR < 10 ensures only the first 9 lines are printed.

Combining grep and awk

For more refined filtering, combine grep and awk. For example, to find lines containing a specific IP and then extract the HTTP paths:

bash

grep "42.236.10.117" log.txt | awk '{print $7}'

Explanation:

    grep "42.236.10.117" log.txt: Filters lines with the specified IP.
    awk '{print $7}': Extracts the seventh field (e.g., HTTP path) from those lines.

Advanced awk Features

awk supports complex operations such as arithmetic computations, string manipulations, and conditional processing. Explore the awk Manual for advanced usage.
Editing Streams with sed

sed (stream editor) is a powerful tool for parsing and transforming text. It can perform complex text manipulations on data streams or files.
Basic Substitution

To replace occurrences of "Mozilla" with "Godzilla":

bash

sed 's/Mozilla/Godzilla/g' log.txt

Listing 2-27: Replacing Text in a File

bash

$ sed 's/Mozilla/Godzilla/g' log.txt

Explanation:

    s/Mozilla/Godzilla/g: Substitutes all (g for global) instances of "Mozilla" with "Godzilla".

Redirecting Output to a New File

To save changes without modifying the original file:

bash

sed 's/Mozilla/Godzilla/g' log.txt > newlog.txt

Explanation:

    Redirects the modified content to newlog.txt.

Removing Whitespace

To delete all whitespace characters:

bash

sed 's/ //g' log.txt

Explanation:

    s/ //g: Removes all spaces globally.

Deleting Specific Lines
Delete the First Line

bash

sed '1d' log.txt

Explanation:

    1d: Deletes the first line of the file.

Delete the Last Line

bash

sed '$d' log.txt

Explanation:

    $d: Deletes the last line of the file.

Delete Multiple Lines (e.g., Lines 5 to 7)

bash

sed '5,7d' log.txt

Explanation:

    5,7d: Deletes lines 5 through 7.

Printing Specific Line Ranges

To print lines 2 through 15:

bash

sed -n '2,15p' log.txt

Explanation:

    -n: Suppresses automatic printing.
    '2,15p': Prints only lines 2 through 15.

In-Place Editing with -i

To modify the file directly:

bash

sed -i '1d' log.txt

Explanation:

    -i: Edits the file in place, saving changes directly to log.txt.

Advanced sed Features

sed supports a multitude of operations including insertion, appending, substitution with regular expressions, and more. Refer to the sed Manual for comprehensive details.
Additional Examples and Practical Use Cases

To further illustrate the capabilities of grep, awk, and sed, let's explore more diverse and practical examples.
Advanced grep Examples
Counting Occurrences of a Pattern

To count how many times a specific IP address appears:

bash

grep -c "35.237.4.214" log.txt

Explanation:

    -c: Counts the number of matching lines.

Displaying Line Numbers with Matches

To display line numbers where the pattern matches:

bash

grep -n "35.237.4.214" log.txt

Explanation:

    -n: Prefixes each matching line with its line number.

Matching Whole Words

To match whole words only:

bash

grep -w "error" log.txt

Explanation:

    -w: Ensures that "error" is matched as a whole word, not as part of another word like "errors".

Advanced awk Examples
Summing Numeric Fields

To calculate the sum of a numeric field (e.g., HTTP status codes):

bash

awk '{sum += $6} END {print sum}' log.txt

Explanation:

    {sum += $6}: Adds the sixth field of each line to sum.
    END {print sum}: After processing all lines, prints the total sum.

Filtering Based on Conditions

To print lines where the HTTP status code is 200:

bash

awk '$6 == 200 {print $0}' log.txt

Explanation:

    $6 == 200: Checks if the sixth field equals 200.
    {print $0}: Prints the entire line if the condition is met.

Using Variables and Field Separators

To extract and format specific fields:

bash

awk -F' ' '{ip=$1; method=$3; path=$4; print "IP:" ip ", Method:" method ", Path:" path}' log.txt

Explanation:

    -F' ': Sets the field separator to a space.
    Extracts the first, third, and fourth fields and formats them into a readable string.

Advanced sed Examples
Inserting Text Before a Pattern

To insert "START" before every line containing "ERROR":

bash

sed '/ERROR/i START' log.txt

Explanation:

    /ERROR/: Targets lines containing "ERROR".
    i START: Inserts "START" before the matched lines.

Appending Text After a Pattern

To append "END" after every line containing "SUCCESS":

bash

sed '/SUCCESS/a END' log.txt

Explanation:

    /SUCCESS/: Targets lines containing "SUCCESS".
    a END: Appends "END" after the matched lines.

Changing Delimiters in URLs

To replace http:// with https:// in URLs:

bash

sed 's|http://|https://|g' log.txt

Explanation:

    Uses | as the delimiter instead of / to avoid conflict with URL slashes.
    Replaces all instances of http:// with https://.

Deleting Lines Matching a Pattern

To delete all lines containing the word "DEBUG":

bash

sed '/DEBUG/d' log.txt

Explanation:

    /DEBUG/: Targets lines containing "DEBUG".
    d: Deletes those lines.

Performing Multiple sed Commands

To perform multiple substitutions in one command:

bash

sed -e 's/ERROR/ERR/g' -e 's/WARNING/WARN/g' log.txt

Explanation:

    -e 's/ERROR/ERR/g': Replaces "ERROR" with "ERR".
    -e 's/WARNING/WARN/g': Replaces "WARNING" with "WARN".

Practical Use Cases
1. Analyzing Web Server Logs

Scenario: Extract all unique IP addresses that have accessed the server.

Solution:

bash

awk '{print $1}' log.txt | sort | uniq

Explanation:

    awk '{print $1}' log.txt: Extracts the first field (IP addresses).
    sort: Sorts the IP addresses.
    uniq: Removes duplicate entries, listing unique IPs.

2. Monitoring System Processes

Scenario: Find all running Python processes and display their process IDs.

Solution:

bash

ps aux | grep python | grep -v grep | awk '{print $2}'

Explanation:

    ps aux: Lists all running processes.
    grep python: Filters processes related to Python.
    grep -v grep: Excludes the grep command itself from the results.
    awk '{print $2}': Extracts the second field (Process ID).

3. Cleaning Configuration Files

Scenario: Remove all commented lines (starting with #) from a configuration file.

Solution:

bash

sed '/^#/d' config.conf > clean_config.conf

Explanation:

    /^#/d: Deletes lines that start with #.
    Redirects the cleaned content to clean_config.conf.

4. Extracting Specific Data from CSV Files

Scenario: From a CSV file, extract the names and email addresses of users.

Solution:

bash

awk -F',' '{print $2, $5}' users.csv

Explanation:

    -F',': Sets the field separator to a comma.
    {print $2, $5}: Prints the second and fifth fields (e.g., Name and Email).

5. Reformatting Log Files

Scenario: Change the date format in a log file from YYYY-MM-DD to DD/MM/YYYY.

Solution:

bash

sed 's/\([0-9]\{4\}\)-\([0-9]\{2\}\)-\([0-9]\{2\}\)/\3\/\2\/\1/g' log.txt > reformatted_log.txt

Explanation:

    Uses regex to capture year, month, and day.
    Rearranges the captured groups to the desired format.

Understanding Foreground and Background Jobs

In Bash, commands run in the foreground occupy the terminal until they complete. This means you cannot execute other commands in the same terminal until the foreground job finishes. On the other hand, background jobs allow you to run commands without blocking the terminal, enabling you to continue working while the job executes.
Foreground Jobs

A foreground job is any command that you run directly in the terminal without appending an ampersand (&). For example:



sleep 100

This command will block the terminal for 100 seconds.
Background Jobs

To run a command in the background, append an ampersand (&) at the end:

bash

sleep 100 &

This command runs sleep 100 as a background job, freeing up the terminal for other commands immediately.
Managing Jobs

Managing foreground and background jobs involves various commands that allow you to control their execution state.
Running Commands in the Background

When you append an ampersand (&) to a command, it runs in the background:

bash

sleep 100 &

Listing 2-28: Running a Command in the Background

bash

$ sleep 100 &
[1] 1827

Explanation:

    The output [1] 1827 indicates that the job ID is 1 and the process ID (PID) is 1827.

Viewing Current Jobs

Use the jobs command to list all current jobs associated with the terminal session:

bash

jobs

Listing 2-29: Viewing Current Jobs

bash

$ jobs
[1]+  Running                 sleep 100 &

Explanation:

    [1]+ is the job ID.
    Running indicates the current state of the job.
    sleep 100 & is the command running in the background.

Bringing Jobs to the Foreground

To move a background job to the foreground, use the fg command followed by the job ID:

bash

fg %1

Listing 2-30: Bringing a Job to the Foreground

bash

$ fg %1
sleep 100

Explanation:

    fg %1 brings job ID 1 (sleep 100) to the foreground.
    The terminal is now occupied by the sleep 100 command until it completes or is suspended.

Suspending and Resuming Jobs
Suspending a Foreground Job

While a foreground job is running, you can suspend it by pressing CTRL-Z:

bash

sleep 100
^Z
[1]+  Stopped                 sleep 100

Explanation:

    Pressing CTRL-Z sends a SIGTSTP signal, suspending the job.
    The job state changes to Stopped.

Resuming a Suspended Job in the Background

Use the bg command to resume a suspended job in the background:

bash

bg %1

Listing 2-31: Resuming a Suspended Job in the Background

bash

$ bg %1
[1]+ sleep 100 &

Explanation:

    bg %1 resumes job ID 1 (sleep 100) in the background.
    The job state changes back to Running.

Keeping Jobs Running After Logout

By default, background and foreground jobs are terminated when you log out or close the terminal because they receive a SIGHUP (hangup) signal. To keep a job running after logout, use the nohup command.
Using nohup

The nohup command prevents the job from being terminated upon logout:

bash

nohup ./my_script.sh &

Listing 2-32: Running a Script with nohup

bash

$ nohup ./my_script.sh &
[1] 1830

Explanation:

    nohup ensures that my_script.sh continues running even after you log out.
    The output will be redirected to a file named nohup.out by default.

Note:

    To avoid cluttering your filesystem, ensure you manage or delete the nohup.out file if it's not needed.

Using System and Service Managers

Alternatively, you can use system and service managers like systemd to run and manage background services. These managers offer advanced features such as:

    Monitoring: Ensuring the process is running.
    Restarting: Automatically restarting the process if it crashes.
    Logging: Capturing logs and failures.

For more information on systemd, refer to the systemd Manual.
Bash Customizations for Penetration Testers

As penetration testers, you often follow standard workflows across various engagements, whether consulting, bug bounty hunting, or red teaming. Optimizing these workflows with Bash customizations can save time and enhance efficiency.
Placing Scripts in Searchable Paths

Bash searches for executable programs in directories listed in the PATH environment variable. Common directories include /usr/local/sbin, /usr/local/bin, /usr/sbin, /usr/bin, /sbin, and /bin.
Viewing Your PATH

bash

echo $PATH

Sample Output:

javascript

/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

Explanation:

    The output lists directories where Bash looks for executable files.

Adding Scripts to a Directory in PATH

To make your scripts easily executable from any location:

    Place Your Script in /usr/local/bin:

    bash

sudo cp my_script.sh /usr/local/bin/
sudo chmod +x /usr/local/bin/my_script.sh

Execute the Script by Name:

bash

    my_script.sh

Advantages:

    No need to provide the full path or navigate to the script's directory.
    Enhances script accessibility and ease of use.

Alternative Options

If you prefer not to place scripts in a PATH directory:

    Call the Script Directly Using the Full Path:

    bash

/home/user/scripts/my_script.sh

Change to the Script's Directory and Execute It:

bash

cd /home/user/scripts/
./my_script.sh

Use Aliases (Covered in the Next Section).

Add Custom Directories to the PATH:

bash

    export PATH=$PATH:/home/user/custom_scripts

Shortening Commands with Aliases

When frequently using long or complex commands, aliases can map these commands to shorter, more memorable names, saving time and reducing typing effort.
Creating an Alias

For example, if you often use Nmap with specific parameters:

bash

nmap -vv -T4 -p- -sV --max-retries 5 localhost

You can create an alias named quicknmap:

bash

alias quicknmap="nmap -vv -T4 -p- -sV --max-retries 5 localhost"

Usage:

bash

quicknmap

Output:

arduino

Starting Nmap ( https://nmap.org ) at 02-21 22:32 EST
--snip--
PORT    STATE SERVICE
631/tcp open  ipp

Creating an Alias for Your Own Scripts

bash

alias helloworld="bash ~/scripts/helloworld.sh"

Usage:

bash

helloworld

Explanation:

    This alias allows you to run your helloworld.sh script by simply typing helloworld.

Making Aliases Permanent

Aliases created in the terminal session are temporary and will be lost once the session ends. To make them permanent:

    Edit the ~/.bashrc File:

    bash

nano ~/.bashrc

Add Your Aliases at the End of the File:

bash

alias quicknmap="nmap -vv -T4 -p- -sV --max-retries 5 localhost"
alias helloworld="bash ~/scripts/helloworld.sh"

Apply the Changes Immediately:

bash

    source ~/.bashrc

Explanation:

    Adding aliases to ~/.bashrc ensures they are available in every new terminal session.

Customizing the ~/.bashrc Profile

The ~/.bashrc file is executed whenever a new terminal session is started in interactive mode. You can customize it to load functions, variables, aliases, and other configurations automatically.
Adding Custom Variables and Aliases

    Open ~/.bashrc for Editing:

    bash

nano ~/.bashrc

Append Custom Variables and Aliases:

bash

VULN_HOST=1.0.0.22
VULN_ROUTER=10.0.0.254

alias quicknmap="nmap -vv -T4 -p- -sV --max-retries 5 localhost"

Apply the Changes Immediately:

bash

source ~/.bashrc

Verify the Variables:

bash

    echo ${VULN_HOST}
    # Output: 1.0.0.22

    echo ${VULN_ROUTER}
    # Output: 10.0.0.254

Explanation:

    Defining variables like VULN_HOST and VULN_ROUTER makes them readily available in every terminal session.
    Aliases such as quicknmap simplify the execution of frequently used commands.

Importing Custom Scripts

To manage complex customizations, you can create dedicated scripts and import them into your ~/.bashrc file.
Creating a Custom Script

    Create the ~/.pentest.sh File:

    bash

nano ~/.pentest.sh

Add Your Custom Logic:

bash

#!/bin/bash

export VULN_HOST=1.0.0.22
export VULN_ROUTER=10.0.0.254

alias quicknmap="nmap -vv -T4 -p- -sV --max-retries 5 localhost"
alias helloworld="bash ~/scripts/helloworld.sh"

Make the Script Executable:

bash

    chmod +x ~/.pentest.sh

Sourcing the Custom Script in ~/.bashrc

    Edit ~/.bashrc:

    bash

nano ~/.bashrc

Add the Source Command at the End of the File:

bash

source ~/.pentest.sh
# Alternatively, you can use:
# . ~/.pentest.sh

Apply the Changes Immediately:

bash

    source ~/.bashrc

Explanation:

    Sourcing ~/.pentest.sh in ~/.bashrc ensures that all customizations in ~/.pentest.sh are loaded in every new terminal session.

Capturing Terminal Session Activity

During penetration testing, it's common to have multiple terminals open, running various tools that produce extensive output. Capturing this output can be crucial for documentation and evidence.
Using the script Command

The script command records all terminal activity and saves it to a file.
Creating a Session Capture Script

Listing 2-33: Saving Terminal Activity to a File

bash

#!/bin/bash

FILENAME=$(date +%m_%d_%Y_%H:%M:%S).log

# Create the sessions directory if it doesn't exist
if [[ ! -d ~/sessions ]]; then
  mkdir ~/sessions
fi

# Start a script session if not already started
if [[ -z $SCRIPT ]]; then
  export SCRIPT="/home/user/sessions/${FILENAME}"
  script -q -f "${SCRIPT}"
fi

Explanation:

    Generating a Timestamped Filename:
        FILENAME=$(date +%m_%d_%Y_%H:%M:%S).log creates a filename based on the current date and time.
    Creating the ~/sessions Directory:
        Checks if the sessions directory exists; if not, it creates one.
    Starting the script Session:
        If the SCRIPT environment variable is not set, it exports the path to the log file and starts recording the session.
        The -q flag suppresses the start and done messages.
        The -f flag flushes the output after each write.

Integrating the Session Capture Script

    Create the Session Capture Script:

    bash

nano ~/scripts/capture_session.sh

Paste the Script Content:

bash

#!/bin/bash

FILENAME=$(date +%m_%d_%Y_%H:%M:%S).log

if [[ ! -d ~/sessions ]]; then
  mkdir ~/sessions
fi

if [[ -z $SCRIPT ]]; then
  export SCRIPT="/home/user/sessions/${FILENAME}"
  script -q -f "${SCRIPT}"
fi

Make the Script Executable:

bash

chmod +x ~/scripts/capture_session.sh

Source the Script in ~/.bashrc:

bash

    echo "source ~/scripts/capture_session.sh" >> ~/.bashrc
    source ~/.bashrc

Usage:

    Every new terminal session will automatically start recording to a unique log file in the ~/sessions directory.
    To stop recording, type exit or press CTRL-D in the terminal.

Exercise: Pinging a Domain

In this exercise, you'll write a Bash script that accepts two arguments:

    Name: A label for the target (e.g., mysite).
    Target Domain: The domain to ping (e.g., nostarch.com).

The script should perform the following tasks:

    Validate Arguments:
        Throw an error if arguments are missing.
        Exit with the appropriate exit code.

    Ping the Domain:
        Determine whether the ping was successful.

    Write Results to a CSV File:
        Include the following information:
            The name provided to the script.
            The target domain provided to the script.
            The ping result (success or failure).
            The current date and time.

Step-by-Step Instructions
1. Create the Script File

bash

nano ping_domain.sh

2. Add the Following Content to ping_domain.sh

Listing 2-34: ping_domain.sh Script

bash

#!/bin/bash

# Check if exactly two arguments are provided
if [[ $# -ne 2 ]]; then
  echo "Usage: $0 <name> <target_domain>"
  exit 1
fi

NAME="$1"
TARGET="$2"
CSV_FILE="ping_results.csv"
TIMESTAMP=$(date +"%Y-%m-%d %H:%M:%S")

# Ping the target with 1 packet and wait up to 2 seconds
if ping -c 1 -W 2 "$TARGET" > /dev/null 2>&1; then
  RESULT="success"
else
  RESULT="failure"
fi

# Write the result to the CSV file
echo "$NAME,$TARGET,$RESULT,$TIMESTAMP" >> "$CSV_FILE"

# Provide feedback to the user
echo "Ping result for $NAME ($TARGET): $RESULT"

Explanation:

    Argument Validation:
        if [[ $# -ne 2 ]]; then checks if exactly two arguments are provided.
        If not, it prints usage instructions and exits with status code 1.

    Variable Assignment:
        NAME and TARGET store the script's arguments.
        CSV_FILE specifies the output CSV file.
        TIMESTAMP captures the current date and time.

    Pinging the Target:
        ping -c 1 -W 2 "$TARGET" sends one ping packet with a 2-second timeout.
        > /dev/null 2>&1 redirects both standard output and standard error to /dev/null to suppress output.
        The if statement checks the exit status of the ping command to determine success or failure.

    Writing to CSV:
        echo "$NAME,$TARGET,$RESULT,$TIMESTAMP" >> "$CSV_FILE" appends the results to ping_results.csv.

    User Feedback:
        Prints the result of the ping to the terminal.

3. Make the Script Executable

bash

chmod +x ping_domain.sh

4. Run the Script

Example Execution:

bash

./ping_domain.sh mysite nostarch.com

Possible Output:

java

Ping result for mysite (nostarch.com): success

Explanation:

    The script pings nostarch.com and logs the result with the name mysite to ping_results.csv.

5. Check the CSV File

bash

cat ping_results.csv

Sample Output:

mysite,nostarch.com,success,2024-04-27 14:35:22

Explanation:

    The CSV file contains the name, target domain, ping result, and timestamp.

Conclusion

Job control is a vital aspect of Bash scripting, allowing you to manage the execution state of your scripts and commands effectively. By mastering foreground and background jobs, using commands like jobs, fg, bg, and leveraging tools like nohup, you can optimize your workflows, especially in scenarios requiring long-running or continuous scripts.

Additionally, customizing your Bash environment with aliases, placing scripts in searchable paths, and capturing terminal sessions enhances your productivity as a penetration tester. These techniques ensure that your scripts are easily accessible, your commands are efficient, and your session activities are well-documented for future reference.
References

    GNU Bash Manual
    systemd Manual
    GNU nohup Manual
    GNU script Manual

Download Scripts

You can download the scripts referenced in this section from the GitHub Repository.
Example Executions
Running a Command in the Background

bash

$ sleep 100 &
[1] 1827

Explanation:

    The sleep 100 command runs in the background, allowing you to continue using the terminal.

Viewing Current Jobs

bash

$ jobs
[1]+  Running                 sleep 100 &

Explanation:

    Lists all current jobs with their statuses.

Bringing a Job to the Foreground

bash

$ fg %1
sleep 100

Explanation:

    Moves job ID 1 (sleep 100) to the foreground.

Suspending a Foreground Job

bash

$ fg %1
sleep 100
^Z
[1]+  Stopped                 sleep 100

Explanation:

    Pressing CTRL-Z suspends the sleep 100 job.

Resuming a Suspended Job in the Background

bash

$ bg %1
[1]+ sleep 100 &

Explanation:

    Resumes the suspended sleep 100 job in the background.

Keeping a Job Running After Logout with nohup

bash

$ nohup ./my_script.sh &
[1] 1830

Explanation:

    Runs my_script.sh in the background, ensuring it continues running after logout.

Using Aliases

bash

$ alias quicknmap="nmap -vv -T4 -p- -sV --max-retries 5 localhost"
$ quicknmap
Starting Nmap ( https://nmap.org ) at 02-21 22:32 EST
--snip--
PORT    STATE SERVICE
631/tcp open  ipp

Explanation:

    Defines and uses an alias quicknmap to execute a complex Nmap command easily.

Capturing Terminal Session Activity

bash

$ ./capture_session.sh

Explanation:

    Starts recording the terminal session, saving all activity to a timestamped log file in the ~/sessions directory.
    To stop recording, type exit or press CTRL-D.

Exercise Execution

Running the ping_domain.sh Script:

bash

$ ./ping_domain.sh mysite nostarch.com
Ping result for mysite (nostarch.com): success

Result:

    The script logs the ping result to ping_results.csv and provides feedback in the terminal.

Checking the CSV File:

bash

$ cat ping_results.csv
mysite,nostarch.com,success,2024-04-27 14:35:22

Explanation:

    Confirms that the ping result has been successfully recorded.
